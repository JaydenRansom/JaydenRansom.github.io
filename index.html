<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="随笔记录学习历程">
<meta property="og:type" content="website">
<meta property="og:title" content="JaydenRansom&#39;s Blog">
<meta property="og:url" content="https://jaydenransom.github.io/index.html">
<meta property="og:site_name" content="JaydenRansom&#39;s Blog">
<meta property="og:description" content="随笔记录学习历程">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JaydenRansom&#39;s Blog">
<meta name="twitter:description" content="随笔记录学习历程">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://jaydenransom.github.io/"/>





  <title>JaydenRansom's Blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JaydenRansom's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Java初级码农</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://jaydenransom.github.io/2017/11/13/Java多线程学习（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jayden Ransom">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JaydenRansom's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/13/Java多线程学习（一）/" itemprop="url">Java多线程学习（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-13T23:21:13+08:00">
                2017-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mutithread/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="操作系统级别的进程与线程"><a href="#操作系统级别的进程与线程" class="headerlink" title="操作系统级别的进程与线程"></a>操作系统级别的进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>一个计算机程序的运行实例。包含了需要执行的指令，有自己的独立地址空间，是互相隔离的。进程拥有各种资源和状态信息，包括打开的文件、子进程和信号处理。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>表示程序的执行流程，是CPU调度执行的基本单位。线程有自己的程序计数器、相同的地址空间、同时共享进程所拥有的内存和其他资源。</p>
<h2 id="Java中的并发编程简介"><a href="#Java中的并发编程简介" class="headerlink" title="Java中的并发编程简介"></a>Java中的并发编程简介</h2><h3 id="并发编程的优点："><a href="#并发编程的优点：" class="headerlink" title="并发编程的优点："></a>并发编程的优点：</h3><p>并发编程可以使程序执行速度得到极大提高，或者为设计某些类型的程序提供更易用的模型。</p>
<h3 id="Java中并发的常用之处："><a href="#Java中并发的常用之处：" class="headerlink" title="Java中并发的常用之处："></a>Java中并发的常用之处：</h3><p>Web应用是最常见的Java系统之一，而基本的Web库类、Servlet具有天生的多线程性。此外，图形化用户界面Swing和SWT类库都拥有针对线程安全的机制，要熟练的掌握仍然需要理解并发。</p>
<h3 id="Java线程机制简介："><a href="#Java线程机制简介：" class="headerlink" title="Java线程机制简介："></a>Java线程机制简介：</h3><p>Java线程机制是抢占式（非协作式）的，这意味着调度机制会周期性地中断线程，将上下文切换到另一个线程。</p>
<h2 id="Java中的简单线程编程实现"><a href="#Java中的简单线程编程实现" class="headerlink" title="Java中的简单线程编程实现"></a>Java中的简单线程编程实现</h2><h3 id="java中实现最简单的线程编程"><a href="#java中实现最简单的线程编程" class="headerlink" title="java中实现最简单的线程编程"></a>java中实现最简单的线程编程</h3><h4 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h4><p>　　要想定义任务，则需要实现Runnable接口并编写run( )方法，使得该任务可以执行自己的想法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> Jayden Ransom</div><div class="line"> * mainTask类实现Runnable接口定义一个任务，testMain在主线程中启动该任务。</div><div class="line"> * </div><div class="line"> * */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numIncrease = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskIncrease = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> taskId = taskIncrease++;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"这是第"</span> + taskId + <span class="string">"个正在执行的任务的第"</span> + numIncrease + <span class="string">"次执行"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建任务，必须编写run方法，这将被调用从而启动任务</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(numIncrease &lt;= <span class="number">10</span>) &#123;</div><div class="line">            System.out.println( toString() );</div><div class="line">            numIncrease++;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注: <code>要想从Runnable导出一个类，则这个类必须有run( )方法</code><br>    <code>实现Runnable接口只是定义一个任务，该类并没有任何内在的线程能力</code><br>下面的实例中，我们在主方法中实例化MainTask类来在主线程（分配给main的那个线程）中调用此任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在TestMain的主方法中，通过创建MainTask类的对象在主线程中调用此任务</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        MainTask mainTask = <span class="keyword">new</span> MainTask();</div><div class="line">        mainTask.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*Sample Output:</span></div><div class="line">这是第1个正在执行的任务的第1次执行</div><div class="line">这是第1个正在执行的任务的第2次执行</div><div class="line">这是第1个正在执行的任务的第3次执行</div><div class="line">这是第1个正在执行的任务的第4次执行</div><div class="line">这是第1个正在执行的任务的第5次执行</div><div class="line">这是第1个正在执行的任务的第6次执行</div><div class="line">这是第1个正在执行的任务的第7次执行</div><div class="line">这是第1个正在执行的任务的第8次执行</div><div class="line">这是第1个正在执行的任务的第9次执行</div><div class="line">这是第1个正在执行的任务的第10次执行</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h4 id="驱动任务"><a href="#驱动任务" class="headerlink" title="驱动任务"></a>驱动任务</h4><p>　　经过上面对 <code>定义任务</code> 的了解，相信大家已经对于如何在java中创建任务有了了解。但是单单定义任务并不能满足我们的需要。我们的目的是将定义的Runnable对象转变为工作任务。<br>　　要想驱动任务，则需要将这个Runnable对象提交给一个Thread构造器。</p>
<p>Thread类的最基本方法：</p>
<pre><code>- Thread.start( )方法：该方法为该线程（即将执行构造器中的任务的线程）执行必需的初始化操作，然后调用Runnable的run( )方法，从而在这个新线程中启动该任务。
- Thread.sleep( int )方法：该方法的参数为以毫秒（ms）为单位，意在中止当前线程执行的任务指定的时间。但是该写法已经过时，目前Java SE（5/6及以上）新写法为 TimeUnit.MILLISECONDS.sleep( int )
-Thread.yield( )方法：该方法的调用是对线程调度器的一种建议。这一方法的调用意在声明该进程中正在执行的任务已经完成了生命周期中最重要的部分了，此刻将时间片分给其他任务使用会造成比较小的额外开销。
</code></pre><p>有关于更多关于Thread类的方法的在后续文章中会逐步介绍。</p>
<p>下面这个例子展示了如何通过Thread类来驱动任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> Jayden Ransom</div><div class="line"> * 将定义好的任务交给Thread构造器，利用Thread驱动任务。</div><div class="line"> * 这里中的MainTask类已经在上面的代码中定义，故此处不再重复定义</div><div class="line"> * */</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">         Thread testThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MainTask());</div><div class="line">         testThread.start();</div><div class="line">         System.out.println(<span class="string">"任务已初始化完毕"</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"><span class="comment">/*Sample Output:</span></div><div class="line">所有任务已经准备就绪</div><div class="line">这是第1个正在执行的任务的第1次执行</div><div class="line">这是第1个正在执行的任务的第2次执行</div><div class="line">这是第1个正在执行的任务的第3次执行</div><div class="line">这是第1个正在执行的任务的第4次执行</div><div class="line">这是第1个正在执行的任务的第5次执行</div><div class="line">这是第1个正在执行的任务的第6次执行</div><div class="line">这是第1个正在执行的任务的第7次执行</div><div class="line">这是第1个正在执行的任务的第8次执行</div><div class="line">这是第1个正在执行的任务的第9次执行</div><div class="line">这是第1个正在执行的任务的第10次执行</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>下面这个例子显示了如何创建多个线程，同时驱动多个任务（由于输出过多，样例输出省略了一部分）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> Jayden Ransom</div><div class="line"> * 将定义好的任务交给多个Thread构造器，利用Thread驱动多个任务。</div><div class="line"> * </div><div class="line"> * */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreThreadTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MainTask()).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*Sample Output:</span></div><div class="line">这是第2个正在执行的任务的第1次执行</div><div class="line">这是第5个正在执行的任务的第1次执行</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">这是第1个正在执行的任务的第2次执行</div><div class="line">这是第1个正在执行的任务的第3次执行</div><div class="line">这是第1个正在执行的任务的第4次执行</div><div class="line">这是第1个正在执行的任务的第5次执行</div><div class="line">.</div><div class="line">.</div><div class="line">这是第5个正在执行的任务的第5次执行</div><div class="line">.</div><div class="line">.</div><div class="line">这是第5个正在执行的任务的第9次执行</div><div class="line">这是第5个正在执行的任务的第10次执行</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">这是第2个正在执行的任务的第9次执行</div><div class="line">这是第4个正在执行的任务的第6次执行</div><div class="line">这是第4个正在执行的任务的第7次执行</div><div class="line">.</div><div class="line">.</div><div class="line">这是第3个正在执行的任务的第9次执行</div><div class="line">这是第3个正在执行的任务的第10次执行</div><div class="line">这是第1个正在执行的任务的第10次执行</div><div class="line">这是第4个正在执行的任务的第10次执行</div><div class="line">这是第2个正在执行的任务的第10次执行</div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h3 id="管理多个Thread"><a href="#管理多个Thread" class="headerlink" title="管理多个Thread"></a>管理多个Thread</h3><p>之前我们接触的例子都是只有一个任务，并由一个Thread对象驱动的简单例子。但往往在我们的实际编程中，会有好多时候需要多个Thread对象驱动任务，这里我们引进Java SE5的java.util.concurrent包中的Executor（执行器）类。Executor类将为我们管理Thread对象，从而简化并发编程。<br>下面是一个简单的使用Executor的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> Jayden Ransom</div><div class="line"> * 使用Executor的例子</div><div class="line"> * */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="comment">//使用静态方法创建Executor对象</span></div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            exec.execute(<span class="keyword">new</span> MainTask() );</div><div class="line">        </div><div class="line">        &#125;</div><div class="line">                <span class="comment">//这里对shutdown()方法的调用是防止新的任务添加到这个Executor   </span></div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;   </div><div class="line"><span class="comment">/*Sample Output:</span></div><div class="line">这是第2个正在执行的任务的第1次执行</div><div class="line">这是第1个正在执行的任务的第1次执行</div><div class="line">这是第1个正在执行的任务的第2次执行</div><div class="line">这是第1个正在执行的任务的第3次执行</div><div class="line">...</div><div class="line">这是第2个正在执行的任务的第10次执行</div><div class="line">这是第4个正在执行的任务的第7次执行</div><div class="line">这是第4个正在执行的任务的第8次执行</div><div class="line">...</div><div class="line">这是第3个正在执行的任务的第9次执行</div><div class="line">这是第4个正在执行的任务的第9次执行</div><div class="line">这是第4个正在执行的任务的第10次执行</div><div class="line">这是第3个正在执行的任务的第10次执行</div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>注：</p>
<pre><code>- 在例子中我们创建的是一个ExecutorService对象，该对象是使用静态的Executor方法创建的。在这里同样你可能还注意到了我们在初始化Executor对象的时候用的方法是Executors类的 newCachedThreadPool( )方法，这里我们同样还可以调用其他的方法　　　　对ExecutorService对象进行初始化，例如newFixedThreadPool( )方法。
`二者区别`：CachedThreadPool将为每个任务都创建一个线程。而利用FixedThreadPool，可以一次性预先执行代价高昂的线程分配，因而也就可以限制线程的数　　　　　　　　　　量了（相比CachedThreadPool，可以节省每次创建线程的开销）。
</code></pre><p>　　 - ExecutorService对象是使用静态的Executor方法创建的，这个方法可以确定其Executor类型</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了以上的理解，应该对基本的任务以及线程的概念有了一些基本概念。但这仅仅是一个开始，在下一篇博文中，将继续介绍有关线程的知识（重点是对线程的异常问题及共享受限资源的解释）。</p>
<p>参考书籍：《Java编程思想》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://jaydenransom.github.io/2017/11/08/Java内存模型初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jayden Ransom">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JaydenRansom's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/08/Java内存模型初探/" itemprop="url">Java内存模型初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T22:54:09+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JMM（Java-Memory-Model）简介"><a href="#JMM（Java-Memory-Model）简介" class="headerlink" title="JMM（Java Memory Model）简介"></a>JMM（Java Memory Model）简介</h2><p>Java作为一种服务器端开发的强大语言，其多线程编程在实际开发中有着广泛的应用，提到Java多线程编程，要想保证项目在实际应用中满足线程安全，就要了解Java内存模型，懂得其原理，进行辅助开发。<br>众所周知，不同硬件以及不同操作系统的内存访问是由差异的。与C/C++这种直接使用物理硬件和操作系统的内存模型的语言不同，Java作为一种跨平台的编程语言，Java内存模型便是在Java虚拟机规范中定义的一种屏蔽掉不同硬件及不同操作系统的内存访问差异的机制。<br>据《深入理解Java虚拟机》一书中的表述，Java内存模型在JDK 1.5发布后已经成熟和完善起来了。</p>
<h2 id="JMM初探"><a href="#JMM初探" class="headerlink" title="JMM初探"></a>JMM初探</h2><h3 id="Java内存的划分与规定"><a href="#Java内存的划分与规定" class="headerlink" title="Java内存的划分与规定"></a>Java内存的划分与规定</h3><p>JMM中，主要将内存划分为两部分：主内存和工作内存。</p>
<ul>
<li>主内存（线程共享）：存储所有变量（包括<strong>实例字段</strong>、<strong>静态字段</strong>以及<strong>构成数组对象的元素</strong>，不包括 <code>局部变量</code> 和 <code>方法参数</code>）</li>
<li>工作内存（线程私有）：存储被该线程使用到的变量的主内存副本拷贝<br>在线程工作中，其所有对变量的操作均是在工作内存中完成的，线程<strong>不能直接读写主内存中的变量</strong>，工作内存中的信息会定时同步回主内存。</li>
</ul>
<h3 id="工作内存与主内存的交互"><a href="#工作内存与主内存的交互" class="headerlink" title="工作内存与主内存的交互"></a>工作内存与主内存的交互</h3><p>Java内存模型中定义了八种 <code>原子操作</code> 用来进行主内存与工作内存的交互。下面将简单介绍这八种操作，主要包括其作用的对象，以及用途。具体内容还请详见《深入理解Java虚拟机》。这八种操作如下：</p>
<ul>
<li>lock：该操作作用于 <code>主内存</code> 中的变量，作用是把一个变量标识为一条线程独占的状态</li>
<li>unlock：该操作作用于 <code>主内存</code> 中的变量，它将被独占锁定的变量释放，使其可以被其它线程锁定</li>
<li><strong>read</strong>：该操作作用于 <code>主内存</code> 中的变量，作用是<strong>将一个变量的值从主内存传输到线程的工作内存中，供load操作使用</strong></li>
<li><strong>load</strong>：该操作作用于 <code>工作内存</code> 中的变量，作用是<strong>将read操作从主内存中得到的变量值放入工作内存的变量副本中</strong></li>
<li>use：该操作作用于 <code>工作内存</code> 中的变量，作用是将工作内存中一个变量的值传递给执行引擎</li>
<li>assign：该操作作用于 <code>工作内存</code> 中的变量，作用是把一个从执行引擎接收到的值赋给工作内存中的一个变量</li>
<li><strong>store</strong>：该操作作用于 <code>工作内存</code> 中的变量，作用是<strong>将一个变量的值从工作内存传输到主内存中，供write操作使用</strong></li>
<li><strong>write</strong>：该操作作用于 <code>主内存</code> 中的变量，作用是<strong>将store操作从工作内存中得到的变量值放入主内存的变量中</strong></li>
</ul>
<p>由以上八个操作列举可以看出，<code>lock、unlock</code>为一组，作用为对主内存的变量进行加锁解锁；<code>use、assign</code>为一组，作用为执行引擎与工作内存的读取、写入操作；而<code>read、load、store、write</code>这四个操作则是供主线程与工作线程进行数据的同步所用。<br>在Java内存模型的规定中，还规定了以上八种操作在进行基本操作时必须满足的基本规则，这些规则与八种基本操作共同构成了JMM的核心。对于具体的规则在《深入理解Java虚拟机》一书里已经有了很详细的讲解，在此不再赘述。</p>
<h2 id="JMM的特性"><a href="#JMM的特性" class="headerlink" title="JMM的特性"></a>JMM的特性</h2><p>Java内存模型（Java Memory Model）主要有三个特性：原子性、可见性与有序性。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>上文介绍的八种操作均为原子操作，其在最基本层次保证了基本数据类型读写的原子性。同时，学习过Java语言的应该对 <code>synchronized</code> 这个关键字也不会陌生，对于被synchronized修饰的块内，操作也可以认为是原子的。这就保证了非基本数据类型的操作的原子性。（关于synchronized的实现原理，将在单独文章中进行介绍）</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>在上文的八种操作介绍中，我们知道，若想让两个线程共享变量，则需要在一个线程更新该变量后，将该变量同步回主内存，然后另一个线程在读取时，首先从主内存中获取进行更新，然后读取。这就保证了线程间的可见性。</p>
<h4 id="volatile、final、synchronized实现可见性"><a href="#volatile、final、synchronized实现可见性" class="headerlink" title="volatile、final、synchronized实现可见性"></a>volatile、final、synchronized实现可见性</h4><ul>
<li>Java中的 <code>volatile</code> 关键字的特殊规则保证了<strong>新值能够立刻同步到主内存</strong>，以及<strong>每次使用前都从主内存刷新</strong>，这便保证了多线程操作时变量的可见性</li>
<li>由于JMM规定，在对一个变量执行unlock之前，必须将该变量同步回主内存，所以在synchronized的使用结束后，便可以保证主内存中的变量已经被更新，这也就保证了可见性</li>
<li>final修饰的对象，由于其在类加载完成过后一旦初始化完成，便可以被访问，故也可保证可见性</li>
</ul>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>Java语言中，volatile关键字的其中一个语义便是禁止指令重排序，故可以保证有序性；synchronized关键字则通过其对象锁控制，控制同一时刻一个对象的对象锁只能被一个线程获取，来保证串行，保证有序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文算是博主个人的一个读书笔记，初读第一遍这部分的时候觉得晦涩难懂，在处理过一些多线程场景之后，再回来阅读该部分，对JMM便有了一些初步的理解。JMM主要围绕着一组定义而展开，这些定义便是帮助我们判断线程安全的基础，有了这些知识基础，才能够更好的处理多线程环境下的编程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://jaydenransom.github.io/2017/11/08/Java与代理——cglib基本使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jayden Ransom">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JaydenRansom's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/08/Java与代理——cglib基本使用/" itemprop="url">Java与代理——cglib基本使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T22:39:07+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cglib与asm简介"><a href="#cglib与asm简介" class="headerlink" title="cglib与asm简介"></a>cglib与asm简介</h2><p><code>ASM</code> 是能够生成Java字节码的一个开源框架。其能够修改已有类或者动态生成类，其操作结果为产生Java字节码文件，同时可以修改Java字节码文件。<br><code>cglib</code> 底层运用了ASM这一字节码操纵框架，其主要作用是通过继承的方式实现动态代理。利用cglib实现动态代理，相比于JDK原生动态代理来说，避免了必须实现接口的要求。但是cglib也不是万能的，由于其需要通过继承方式完成动态代理，所以其无法对 <code>final</code> 关键字修饰的类进行代理增强。</p>
<h2 id="cglib的入门使用"><a href="#cglib的入门使用" class="headerlink" title="cglib的入门使用"></a>cglib的入门使用</h2><p>了解了cglib的基本概念，我们来看一个简单利用cglib实现方法增强的例子。<br>该工程使用maven进行依赖管理，在编写之前需加入cglib的maven依赖，pom文件中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;cglib&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;cglib&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;3.2.5&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>实例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">要被代理的类的声明如下：</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 被代理类方法，原本业务逻辑实现</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"生产者：我卖出了一个作品"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">代理的声明如下：</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMarket</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写实现增强的方法</div><div class="line">     * <span class="doctag">@param</span> o</div><div class="line">     * <span class="doctag">@param</span> method,</div><div class="line">     * <span class="doctag">@param</span> objects,</div><div class="line">     * <span class="doctag">@param</span> methodProxy,</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Throwable</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//前置增强</span></div><div class="line">        System.out.println(<span class="string">"代理商场：卖出货物"</span>);</div><div class="line">        <span class="comment">//调用需要被代理的方法</span></div><div class="line">        methodProxy.invokeSuper(o, objects);</div><div class="line">        <span class="comment">//后置增强</span></div><div class="line">        System.out.println(<span class="string">"后置增强实例"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">主类（测试类）声明如下：</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buyer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">        enhancer.setSuperclass(Producer.class);</div><div class="line">        enhancer.setCallback(<span class="keyword">new</span> SuperMarket());</div><div class="line">        Producer producer = (Producer) enhancer.create();</div><div class="line">        producer.sale();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Output:</div><div class="line">代理商场：卖出货物</div><div class="line">生产者：我卖出了一个作品</div><div class="line">后置增强实例</div></pre></td></tr></table></figure></p>
<p>此例展示了一个最基本的利用cglib字节码生成库进行方法增强的示例，下面我们来进行代码的分析。<br>从 <code>主方法</code> 开始，我们可以看到，首先构造了一个 <code>net.sf.cglib.proxy.Enhancer</code> 类型的对象，分别通过其<strong>setSuperclass</strong>和<strong>setCallback</strong>方法分别设置父类（被代理类）和代理类。然后通过其<strong>create</strong>方法来构造一个代理对象，通过该代理对象调用方法，便实现了动态代理。<br>再看 <code>MethodInterceptor</code> 的实现，cglib实现动态代理的方式中，要求代理类需要实现MethodInterceptor接口，实现该接口中定义的 <code>public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable</code>方法，该方法在通过代理类调用被代理方法时，被调用执行，进行方法的增强。其四个参数的意义分别为：</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://jaydenransom.github.io/2017/08/22/浅谈单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jayden Ransom">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JaydenRansom's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/浅谈单例模式/" itemprop="url">浅谈单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T22:59:53+08:00">
                2017-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单例模式简介"><a href="#单例模式简介" class="headerlink" title="单例模式简介"></a>单例模式简介</h2><p>单例模式作为GOF 23种常见设计模式的一种，在J2EE不断发展和逐渐成熟中有着广泛的应用。其中Java Web的核心组件servlet在tomcat容器中便是单例存在的。同样，目前主流Web架构广泛使用的Spring框架，在其IoC容器中，Bean实例同样也是单例存在的。<br>实现单例模式，我们需要首先需要保证两个最基本的要求，即构造方法私有化和给外界一个可以访问实例对象的public方法。构造方法私有化可以保证这个实例由其内部自行创建，这能够保证其能够创建自身的唯一实例；给外界一个public方法可以使得应用方可以使用这一实例，这二者构成了最基本的单例模式的思想。下面给出一个最基本的单例模式的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm in the single instance"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Single.getInstance().print();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Output:</div><div class="line">I<span class="string">'m in the single instance</span></div></pre></td></tr></table></figure></p>
<p>由上例可以看出，我们通过最简单的方式，即创建静态对象，使其在类加载期进行初始化，完成对象的实例化；同时通过将构造方法私有，导致外界无法调用构造方法来构造此类的实例对象，这便保证了单例。同时，我们提供给外界一个公有方法可以获取该实例，并进行方法的调用。<br>以上这种方法仅是一种容易理解的单例模式的实现；虽然其实现了单例模式，但是由于是静态对象持有，在类加载的时候便会构建实例，所以如果类加载后一段时间不用该实例的话，就会导致内存的浪费；这必定不是一种很好的方案，下面就让我们了解几个单例模式构建中的最佳实践（其实也不算最佳啦= =根据实际场景各取所需才是王道嗯！）</p>
<h2 id="懒汉与饿汉"><a href="#懒汉与饿汉" class="headerlink" title="懒汉与饿汉"></a>懒汉与饿汉</h2><h3 id="区分懒汉与饿汉"><a href="#区分懒汉与饿汉" class="headerlink" title="区分懒汉与饿汉"></a>区分懒汉与饿汉</h3><p>所谓 <code>懒汉式</code> 和 <code>饿汉式</code>，指的是单例实例加载的时间。由之前举的例子，可知上例维护了一个静态对象引用的持有，该单例对象在类创建时就已加载，故属于 <code>饿汉式</code> 加载；这种方法好处是在初始化时候加载，不许在后续创建时保证线程安全；但如果该类加载后一段时间不使用，则会出现内存占用的情况，故饿汉式单例模式不能应用去全部需要单例的场景。</p>
<h3 id="懒汉式单例模式的实现"><a href="#懒汉式单例模式的实现" class="headerlink" title="懒汉式单例模式的实现"></a>懒汉式单例模式的实现</h3><p>相对而谈，<code>懒汉式</code> 加载方式则是在真正第一次使用的时候进行实例的创建，这样有效的避免了 <code>饿汉式</code> 方式带来的内存浪费。下面列举一个懒汉式单例模式的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//提供给外部访问实例的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Single();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中我们可以看到，我们没有像 <code>饿汉</code> 模式一样在类加载的时候就构建实例，而是等到实际第一次调用的时候进行单例的构建；这样的做法在单线程环境下没有问题，效率也比较高。但是如果我们有两个线程同时要调用获取单例对象的方法，就会可能出现构造出两个对象的情况，这样就不是一个合法的单例模式了，所以该实现方法并不适合于多线程环境下。</p>
<h2 id="单例模式与线程安全"><a href="#单例模式与线程安全" class="headerlink" title="单例模式与线程安全"></a>单例模式与线程安全</h2><h3 id="单例模式中的线程安全情况"><a href="#单例模式中的线程安全情况" class="headerlink" title="单例模式中的线程安全情况"></a>单例模式中的线程安全情况</h3><p>目前在主流应用中，都采用分布式、多线程的方式进行工作，这就造成了我们在很多时候编程中应该保证线程安全，这样才能保证程序运行的正确性。所以我们需要在多线程开发环境下保证线程安全。<br>首先来观察上文展示的饿汉模式实现的单例模式，在上例中我们可以看出由于在类加载后便创建完单例对象并持有该对象的引用，所以在使用的过程中不会出现线程安全问题。而上例的懒汉式单例模式的实现中，由于可能同时出现在第一次调用getInstance()方法进入if分支的时候，另一个线程得到时间片，也进入该分支，所以在这种情况下就会出现构造出两个实例，违反了单例模式的要求，所以其不能在多线程环境下满足单例的需求。<br>继续进行思考，我们可以通过 <code>加锁</code> 的方式对 <code>getInstance()</code> 方法的调用进行限制，这样就可以防止多线程并发环境下传统懒汉模式可能出现的问题。可以采用的加锁模式有两种：</p>
<ul>
<li>用synchronized对方法进行限制加锁</li>
<li>采用双检锁<br>这两种方法均可用于解决单例模式的线程安全问题，其中第一种方法中，由于用 <code>synchronized</code> 对方法修饰之后，该方法会变成互斥访问的，任何时刻都只能有一个线程调用该方法；也就意味着只要需要获得实例，便需要排队等待上一个调用者释放锁之后才可进行获取，这样的做法并不高校。</li>
</ul>
<h3 id="采用双检索实现线程安全的单例模式"><a href="#采用双检索实现线程安全的单例模式" class="headerlink" title="采用双检索实现线程安全的单例模式"></a>采用双检索实现线程安全的单例模式</h3><p>仔细思考我们的需求，我们实际上需要加锁控制的，是创建单例对象的唯一，即只能有一次创建该单例对象的过程。所以我们只需要保证创建单例对象的过程加锁就可以。 <code>双检</code> 的概念就是一在同步块外判引用是否为空，二在同步块内判引用是否为空。<br>下面是一个利用 <code>双检索</code> 保证线程安全的懒汉模式的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//提供给外部访问实例的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Single.class) &#123;</div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Single();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成上例，博主觉得已经达到绝对的线程安全了。但是在学习的过程中发现很多双检索实现单例模式的过程中都将内部实例 <code>instance</code> 用volatile进行修饰，于是博主去调查了原因，这是由于JVM指令重排序造成的。在JVM中，创建一个对象实例的时候大概有三步：分配内存、调用构造函数和将对象引用指向该对象的内存空间。而JVM在执行的时候可能会将后两个过程进行指令重排序，下面我们想象这样一种情况：A线程进行了单例的创建，但是由于指令重排序，导致将引用已经指向该空间，但是还没有调用构造函数；这时另外一个B线程调用 <code>getInstance()</code> 进行单例的获取，由于引用已经不为空，所以会直接返回该对象引用，但是由于该对象还未进行构造，所以会出现错误。在我们的程序中，应该避免这种情况的发生。</p>
<h3 id="volatile的使用"><a href="#volatile的使用" class="headerlink" title="volatile的使用"></a>volatile的使用</h3><p>由于此篇不是对于 <code>volatile</code> 与 <code>JMM</code> 相关的介绍，所以在此不展开介绍JMM、内存屏障相关知识，只简单介绍volatile在双检锁模式中的作用。<br><code>volatile</code> 关键字，在目前的Java版本中主要有两个语义：</p>
<ul>
<li>保证此变量对所有线程的可见性</li>
<li>禁止指令重排序<br>在双检锁模式的实现中，主要使用volatile关键字的第二个语义，通过将单例对象引用以volatile修饰，达到禁止该变量操作的指令重排序。从而保证线程安全。具体实现很简单，只需要将上例的private对象加volatile修饰即可，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Single instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//提供给外部访问实例的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Single.class) &#123;</div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Single();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式的实现不仅有懒汉模式、饿汉模式，同时还可以使用静态内部类以及枚举来实现单例模式。其中，静态内部类实现单例模式也是线程安全的，同时也满足懒加载。根据不同的需求，可以进行不同方式的构建。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://jaydenransom.github.io/2017/07/29/Java与代理——JDK原生动态代理的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jayden Ransom">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JaydenRansom's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/29/Java与代理——JDK原生动态代理的实现/" itemprop="url">Java与代理——JDK原生动态代理的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-29T13:56:16+08:00">
                2017-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JDK原生实现动态代理"><a href="#JDK原生实现动态代理" class="headerlink" title="JDK原生实现动态代理"></a>JDK原生实现动态代理</h2><p>由上一篇中的代理模式UML类图我们可以看出，代理类和被代理类需要依赖统一接口，代理类通过在接口方法的实现中增加增强逻辑并调用被代理类的实现，实现代理。这样客户端在调用的时候，代理类便可以替代被代理类，并且对外的调用接口相同。<br>静态代理的局限性上篇博文中已经介绍过，即接口声明的方法过多的时候，我们需要逐一进行增强添加，这样在需求变更或者接口更改的时候就会非常麻烦。<br>动态代理在静态代理的基础上，通过Java提供的类通过反射在运行时动态获得接口信息，并对其进行增强。我们先看一个小例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义Produce接口，提供两个行为：分别为售货和支付</div><div class="line"> * Created by gaodongyan on 2017/7/17.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Produce</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by gaodongyan on 2017/7/17.</div><div class="line"> * 定义代理类继承自InvocationHandler，内部持有被代理对象的引用</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMarket</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object producer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperMarket</span><span class="params">(Object producer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.producer = producer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//proxy指代理对象，不是被代理的对象</span></div><div class="line">        System.out.println(proxy.getClass());</div><div class="line">        <span class="comment">//公共增强</span></div><div class="line">        System.out.println(<span class="string">"超市代理：公共增强"</span>);</div><div class="line">        <span class="comment">//针对方法的不同，进行不同的增强</span></div><div class="line">        <span class="keyword">if</span>(<span class="string">"sale"</span>.equals(method.getName())) &#123;</div><div class="line">            System.out.println(<span class="string">"超市代理：超市代理了生产者，进行销售"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"pay"</span>.equals(method.getName())) &#123;</div><div class="line">            System.out.println(<span class="string">"超市代理：产品正在超市销售，超市赚取一定代理销售费用"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//调用被代理类的真实方法</span></div><div class="line">        method.invoke(producer, args);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by gaodongyan on 2017/7/17.</div><div class="line"> * 购买测试类，在该类主方法中进行动态代理的测试</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buyer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Produce producer = <span class="keyword">new</span> Producer();</div><div class="line">        <span class="comment">//InvocationHandler与代理类关联，可以理解为拦截器</span></div><div class="line">        InvocationHandler invocationHandler = <span class="keyword">new</span> SuperMarket(producer);</div><div class="line">        Produce proxy = (Produce) Proxy.newProxyInstance(invocationHandler.getClass().getClassLoader(), producer.getClass().getInterfaces(), invocationHandler);</div><div class="line">        proxy.sale();</div><div class="line">        proxy.pay(<span class="number">20.0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">上述代码运行结果如下：</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sun</span>.<span class="title">proxy</span>.$<span class="title">Proxy0</span></span></div><div class="line">超市代理：公共增强</div><div class="line">超市代理：超市代理了生产者，进行销售</div><div class="line">生产者：我售出了一个货物</div><div class="line"><span class="title">class</span> <span class="title">com</span>.<span class="title">sun</span>.<span class="title">proxy</span>.$<span class="title">Proxy0</span></div><div class="line">超市代理：公共增强</div><div class="line">超市代理：产品正在超市销售，超市赚取一定代理销售费用</div><div class="line">生产者：该货物价格为：20.0</div></pre></td></tr></table></figure></p>
<p>反观上例，我们在创建动态代理的过程中。实际上是自己实现一个实现了InvocationHandler的<code>拦截器</code>（这里的拦截器只是一种比喻，该说法不准确），其中包含一个被代理类的实例引用。<code>InvocationHandler</code>接口中只有一个<code>invoke(Object proxy, Method method, Object[] args)</code>方法，我们便在该方法中实现对于方法的增强。并在实现增强后，调用被代理类的方法。<br>在使用时，我们首先创建proxy对象。该对象关联一个<code>自定义InvocationHandler</code>对象和一个<code>被代理对象</code>。我们调用代理对象的方法时，会转向调用InvocationHandler中的invoke方法。这也就实现了代码的增强（理解起来和Spring AOP类似）。</p>
<h2 id="JDK原生动态代理总结"><a href="#JDK原生动态代理总结" class="headerlink" title="JDK原生动态代理总结"></a>JDK原生动态代理总结</h2><p>在InvocationHandler的实现中，我们可以看到，我们可以对所有方法添加公共的增强；同时也可以针对方法增加特定的增强，这有着很大的灵活性。这也是动态代理的优点之一。但是仔细观察代码实现的原理，JDK原生动态代理是通过反射获得被代理对象所实现的接口方法，并对这些接口方法进行代理和增强。虽然相比静态代理，其免去了需要逐一代理，且当被代理对象实现多个接口的时候，无需为每一个接口创建一个代理类；但是其实现仍然受到接口的约束。这也是动态代理的不足之处。<br>下一篇博文中，将介绍有关使用cglib代码生成库实现动态代理的原理及方法。相比于JDK原生动态代理，cglib具有更大的灵活性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://jaydenransom.github.io/2017/07/22/Java与代理———静态代理与动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jayden Ransom">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JaydenRansom's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/Java与代理———静态代理与动态代理/" itemprop="url">Java与代理———静态代理与动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T16:34:49+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="从代理模式开始"><a href="#从代理模式开始" class="headerlink" title="从代理模式开始"></a>从代理模式开始</h2><p>代理模式作为设计模式的一种，在实际编程应用中有着很多的用处。目前主流使用的Spring框架<code>AOP</code>的实现便是通过动态代理来实现的。博主最近准备研究一下Spring底层源码，首先便由代理模式开始。<br>代理模式的UML类图可以简单描述如下：<br><img src="http://ot4u9yaqn.bkt.clouddn.com/proxy.png" alt="proxy"><br>由类图中我们可以看出，要被代理的真实类和代理类都需要实现一个接口，接口中定义的方法可以在代理类中进行增强与扩展。静态代理就是这么做的。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在静态代理的实现中，主要思路便是构造一个持有要被代理的真实类的一个引用，然后通过自身对于接口的实现，来进行增强与扩展。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.jayden.proxy;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Jayden Ransom on 2017/7/22.</div><div class="line"> * 接口定义，定义sale()方法</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Produce</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Jayden Ransom on 2017/7/22.</div><div class="line"> * 被代理类定义，实现Produce接口</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Produce</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Producer:卖出了一个货物"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Jayden Ransom on 2017/7/22.</div><div class="line"> * 代理类定义，实现Produce接口，同时内部持有一个被代理类的引用</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerProxy</span> <span class="keyword">implements</span> <span class="title">Produce</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Produce produce;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerProxy</span><span class="params">(Produce produce)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.produce = produce;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//添加增强</span></div><div class="line">        proxy();</div><div class="line">        produce.sale();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//增强方法的定义</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">proxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"商店代理销售"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Jayden Ransom on 2017/7/22.</div><div class="line"> * //测试类，进行代理测试</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buyer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Produce producer = <span class="keyword">new</span> Producer();</div><div class="line">        Produce proxy = <span class="keyword">new</span> ProducerProxy(producer);</div><div class="line">        <span class="comment">//调用代理类的sale方法，运行增强后的行为</span></div><div class="line">        proxy.sale();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">运行结果如下：</div><div class="line">商店代理销售</div><div class="line">Producer:卖出了一个货物</div></pre></td></tr></table></figure></p>
<p>上例中，我们主要要完成一个简单的售货逻辑。在现实社会中，我们的售货主要是由商店进行代理。本例中，首先定义了<code>Produce</code>接口，该接口对售货行为进行了约束；<code>Producer</code>类为真正的生产者类，货物是由他们生产的。<code>ProducerProxy</code>类作为代理，在该类的方法实现中，实现了对于方法的增强。<br>在主方法中，我们定义了一个代理类和一个被代理类，通过调用代理类的方法，实现了方法的增强。由于被代理类和代理类均实现了同一接口，所以所有需要用被代理的地方均可以使用代理类进行代理。<br>以上便是静态代理的基本实现。即定义代理类与被代理类实现相同接口，在代理类的方法实现中进行方法的增强。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>由上例可以看出，我们可以通过静态代理的方式对方法进行增强。但是如果方法变多或者接口发生变化，那么代理类中就要对这些方法进行重新实现，这是很麻烦的过程，所以静态代理应用的场景很有局限性。<br>在静态代理基础上，Java语言提供了动态代理机制。动态代理主要用到了Java语言的反射机制，即在运行时期获得类信息、并动态创建对象。<br>目前主要的动态代理实现主要有两种：一种为jdk原生动态代理；另一种为使用<code>cglib</code>这一code生成库实现动态代理。<br>原生动态代理与静态代理一样，均需要通过接口进行。这是由于Java的继承机制引起的，关于这部分内容还会在后期开新的博客。而使用cglib实现的动态代理则摆脱了接口的束缚。<br>在<code>Spring AOP</code>的实现中，同时用到了这两种动态代理。关于具体二者的实现与区别，将在下一篇博文中介绍。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://jaydenransom.github.io/2017/07/16/比较synchronized与lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jayden Ransom">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JaydenRansom's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/16/比较synchronized与lock/" itemprop="url">比较synchronized与lock</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-16T15:06:41+08:00">
                2017-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mutithread/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="共享资源竞争问题"><a href="#共享资源竞争问题" class="headerlink" title="共享资源竞争问题"></a>共享资源竞争问题</h2><p>在Java语言的并发编程中，由于我们不知道线程实际上在何时运行，所以在实际多线程编程中，如果两个线程访问相同的资源，那么由于线程运行的不确定性便会在这种多线程中产生访问错误。所以为了避免这一情况的发生，我们在编程的时候需要把并发执行的线程中用于访问这一共享资源的方法进行同步处理，以避免并发对于共享资源产生的影响。</p>
<p>并发模式在解决线程冲突的问题时，基本上都是采用序列化访问共享资源的方案。这在我的理解中，就是我们要控制同一时刻只能让一个线程对这一共享资源进行访问。</p>
<h2 id="synchronized关键字的使用"><a href="#synchronized关键字的使用" class="headerlink" title="synchronized关键字的使用"></a>synchronized关键字的使用</h2><h3 id="synchronized对于类普通成员方法的修饰"><a href="#synchronized对于类普通成员方法的修饰" class="headerlink" title="synchronized对于类普通成员方法的修饰"></a>synchronized对于类普通成员方法的修饰</h3><p>Java语言中，每一个对象都含有单一的锁（监视器）。而synchronized的作用之一就是修饰使用了共享资源的成员方法，这样在线程通过对象调用该方法时，该对象都会被加锁。这时候如果需要调用该对象的另一个synchronized方法，则需要在第一个方法调用完毕后再进行，这就实现了最基本的同步。</p>
<p>例1：使用synchronized修饰方法和未修饰方法的区别<br>（1）使用synchronized修饰过的方法，在多线程执行的过程中，程序依次输出递增3的数字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronization</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> currentCount = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printAdd</span><span class="params">()</span> </span>&#123;</div><div class="line">        currentCount++;</div><div class="line">        Thread.yield();</div><div class="line">        currentCount++;</div><div class="line">        Thread.yield();</div><div class="line">        currentCount++;</div><div class="line">        System.out.println(currentCount);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        printAdd();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        Synchronization test = <span class="keyword">new</span> Synchronization();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            exec.execute(test);</div><div class="line">        &#125;</div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（2）与之相对应的未用synchronized修饰过的方法，在多线程执行的过程中，程序会输出没有规律的数字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronization</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> currentCount = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAdd</span><span class="params">()</span> </span>&#123;</div><div class="line">        currentCount++;</div><div class="line">        Thread.yield();</div><div class="line">        currentCount++;</div><div class="line">        Thread.yield();</div><div class="line">        currentCount++;</div><div class="line">        System.out.println(currentCount);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        printAdd();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        Synchronization test = <span class="keyword">new</span> Synchronization();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            exec.execute(test);</div><div class="line">        &#125;</div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="synchronized对于类静态成员方法的修饰"><a href="#synchronized对于类静态成员方法的修饰" class="headerlink" title="synchronized对于类静态成员方法的修饰"></a>synchronized对于类静态成员方法的修饰</h3><p>与对象相同，Java的每个类也有一个锁，所以我们可以通过将静态方法用synchronized修饰来控制其对于静态共享资源的访问。</p>
<h2 id="Lock的使用"><a href="#Lock的使用" class="headerlink" title="Lock的使用"></a>Lock的使用</h2><p>在上面的利用synchronized进行同步的描述中，我们都是利用方法所在对象自身的锁来进行同步。除了这种方法之外，我们还可以用Java语言中内置的锁对象来进行显式的加锁。<br><code>Lock</code>接口，便是Java语言在<code>java.util.concurrent.locks</code>包中为我们提供的<code>显式锁</code>。目前在该包中有三个Lock的实现（基于JDK 1.7），分别为<code>ReentrantLock</code>,<code>ReentrantReadWriteLock.ReadLock</code>,<code>ReentrantReadWriteLock.WriteLock</code>。<br>Lock对象必须在程序中被<code>显式</code>的创建、锁定和释放。<br>例3：使用Lock实现多线程之间的同步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> currentCount = <span class="number">0</span>;</div><div class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            currentCount++;</div><div class="line">            Thread.yield();</div><div class="line">            currentCount++;</div><div class="line">            Thread.yield();</div><div class="line">            currentCount++;</div><div class="line">            System.out.println(currentCount);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        addCount();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        LockTest test = <span class="keyword">new</span> LockTest();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            exec.execute(test);</div><div class="line">        &#125;</div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="synchronized与Lock的对比"><a href="#synchronized与Lock的对比" class="headerlink" title="synchronized与Lock的对比"></a>synchronized与Lock的对比</h2><p>在我的理解中，synchronized修饰的方法，在检查到对象已经被加锁的情况后，会等待到该对象锁被释放；之后对对象进行加锁，进行自身方法的执行。<br>但是Lock则不是如此，Lock可以尝试获取锁一段时间，或者尝试获取锁最后失败，而synchronized方式则不可以。综合来说，采用Lock显式锁可以完成更多并发控制功能，但是其较synchronized麻烦许多，所以根据自身程序的需要可以视情况选择这两种同步方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jayden Ransom" />
          <p class="site-author-name" itemprop="name">Jayden Ransom</p>
           
              <p class="site-description motion-element" itemprop="description">随笔记录学习历程</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jayden Ransom</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
